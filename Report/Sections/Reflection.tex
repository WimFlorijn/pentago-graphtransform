\section{Reflection}
\label{Reflection}

\subsection{Henk Mulder}

In this reflection I want to discuss a couple of things.
First of all my general ideas about the concept of graph transformations as a modeling technique.
Then I want to make a brief, shallow comparison to progress algebra, and compare my experiences using both techniques.
And finally I want to reflect a bit on the project.

\subsubsection{General}
Graphs can very conveniently model complex structures. That makes graph transformations a logical way of modeling dynamic evolution of such a structure.
Since graphs are so common in modeling and describing systems - think of Control flow diagrams, communication systems, state charts and all sort of UML diagrams - graphs can convey properties of a system very well, even among different disciplines.
In my opinion graph transformations therefore is a well suited modeling formalism in general.

For me personal thinking about systems in the form of graph structures does give me good insight in the system. However the visual aspect that is mostly used to present graphs make it difficult for me to read them.
Getting an overview of a state graph is very difficult. But a nice compact graph that represents a transformation rule makes the transformation even for me, as a blind person, very understandable.
Making use of this technique in the way I used it during the project; that is by manually editing xml files, is not very productive. 
If there would be a way to edit the graphs in an other way - I'm thinking for instance about using the aldebaran format as input, Or an editor like the ones that are generated in the EMF framework if you generate a (default) editor for an ecore model - then it would be much easier for me to use Groove in practice.

\subsubsection{Graph transformations vs. process algebra}

In graph transformation systems states are modeled as graphs. Transformations are then modeled as rule applications that change the structure of the underlying graph. These rules can be defined without knowing everything about the structure of the underlying graph.
This makes it a very flexible modeling formalism. 

In process algebra transformations are modeled using (compositions of) processes. Interaction between processes is modeled by message passing. Algebraic laws are defined for the process operators, to allow for manipulation by equational reasoning.
In this I see an analogy between a process in process algebra and a transformation rule in graph transformation systems. Both specify how the underlying system changes. 

In process algebra process equivalence is determined by checking for bisimulation. In graph transformation systems this is done by checking for graph isomorphisms in the transformation graph.
Projected on to Groove recipes can then be used to do what hiding is in process algebra. Then checking for graph isomorphism is like checking for weak bisimulation in process algebra.

In the course MACS1 and in the course Verification engineering I have worked with MCRL2.
My feeling is that MCRL2 was faster in checking temporal properties of a system.
But the kind of systems I modeled during that course were very different to the system we modeled for the project. 
And I consider the small toy-examples not as good benchmarks to compare performance in model checking between the two tools.
So I can not make a hard statement about that.
I think it would be interesting to see how they compare performance wise for checking temporal properties on similar models.

I wonder if Groove could improve more on the matching strategy it chooses to match rules. 
I am thinking along the lines of finding dependencies among nodes in rules, and as a strategy then start with nodes to which the most dependencies are.

\subsubsection{The project}

I found it very useful to have a project in which we could do a little more with Groove than just toy-examples. 
In the somewhat larger project we encountered more real-life problems like the trade-off between abstraction and complexity in analysis.
The choice to model pentago was nice in the sense that it was clear to us what to model. The rules of the game are not that difficult to understand.
But we had to compromise between abstraction in our model and the time it took to match the rules. This made it more difficult to create elegant strategies for players.
This immediately showed where the strong and the weak points are in this technique.

It was a shame that we could not really use the verification features of Groove, since we were not able to generate the entire state space for the game.
Verification is perhaps not the main focus of the course. However it is one of the reasons to actually model a system.
If we had chosen a different project then perhaps we could have done more with verification. (Not that a Monte Carlo simulation is not interesting.)

All in all I think 4-5 weeks is really short for such a broad topic. The project takes up a lot of this time. 
Together with the project I think we touched most of the important things on graph transformations. The basics during the lectures, and real-life experience by using it in the project.
It is also clear to me that there is a lot more to it than we have seen so far.

\subsection{Wim Florijn}

In my reflection, i want to look back on my experience of the course as a whole, including the project.
I want to mention the positive points of the course, and give some recommendations to improve it further.
I also want to discuss the troubles that I had and how I overcame them.

\subsubsection{The Course}
During the course i have refreshed my knowledge on graphs, and learned to model with GROOVE.
I find it interesting how graphs, which are often used for describing a system only, are used in GROOVE to program and execute a system as a whole.
In my opinion, GROOVE provides an intuitive way to model problems, and stepwise search for their solution.
I have compared GROOVE in the past with different AI planners, but not realy modeled problems, which proved to be more intuitive than I expected.
The type graph offered support in defining a clear model of the system.

\vspace{6pt}

I liked how during the lectures examples where shown in GROOVE. This way no problems arise because the node/edge syntax is unclear.
The downside of this part of the Software Science course, is that in my opinion it provided too much information to understand and test yourself. Especially the last two lectures introduced some new concepts which seemed interesting, but for whom we had not enough time to investigate and test in practice.
Concretely i would have liked to investigate the model-checking abilities of GROOVE, and try to put the rule priority system in practice instead of only the using the control program (in the project).
In my opinion, the graph transformation part of the course could be offered as a course of its own, so that there is more room to practice all features of GROOVE.

\subsubsection{The Project}

I found the project to be a great addition to the course.  It is one thing to see and work on different small problems, but to combine them into one big project realy helps you to understand the theory.
During the project, it was challenging to come up with solutions which are not only clear and elegant, but also efficient in terms of resources.

\vspace{6pt}

One challenge in modelling pentago, is creating atomic rules which check for a draw. If the game recognizes one player posessing a row of five, it must be sure that the other players don't also possess such a row, before appointing the first player as the winner.
This challenge has been addressed by making the winner and draw graph conditions abstract.
Multiple players matching a winner rule simulthaneously has been addressed by making use of quantifiers.
I also found it interesting to perform a formal evaluation on the performance of the strategies. While i have read about Monte Carlo simulations in the past, i have not put it into practice until now.
Because of the trade-off between elegancy and performance, in my opinion the main control program has become a bit complex.
While i have structured the program into functions, i think it would be more elegant to capture more concepts about the end-game in rules, however when rules become complex, they slow down quickly.
If there was more time, we could have create more complex strategies which involve smart block rotation, but nevertheless i am happy with the performance of our smart strategy.
\vspace{6pt}

I have learned much during this course, and i would choose this course again if i had to reconsider it.


\subsection{Theo Miltenburg}
For me this was the first time I have encountered graph transformations. While I had trouble understanding the sheets the provided paper provided a very solid introduction into this subject. While the provided paper doesn't go into details about GROOVE the manual was there to help. At certain parts the manual is lacking, it is missing certain subjects and there was, for me, a gap between a theoretical background and the manual.\\
When looking at GROOVE I am very pleasantly surprised at the ease of use and the stability of the program. Having worked more often with programs being internally developed at some faculty this has been one of the most stable and easiest to use. I do want to give a few (minor) recommendations about the tool. For us the most critical part during modelling was the performance of the matching. There is litle information available in the manual and the program doesn't provide feedback on the performance of individual steps(only on the execution of an entire trace).

\subsubsection{The project}

When looking at the final model we first started out as a very clear and precise implementation of the problem. During designing our graph production system we first started out with a very small core purely based on graph transformations. This provided a very solid base to build further functionality. As we started introducing more functionality we ran into performance issues. This caused us to change our program to become less flexibel. Rule matching took much less time. Also, our control program grew much in complexity. The use of a control program is very obvious, in our case it was more or less a way to steer the exploration by limiting the allowed transformations or giving priority to certain transformations. Our system could be improved by adding some verifications. This would guard against wrong implementations of rules. 

\subsubsection{Reflection}
While I did get a grasp on GROOVE and some of the modelling issues I do not have extensive knowledge of the subject matter just yet. Especially the part on predicting the performance of certain rules is hard. This basically was a trial and error method. While the course started out by stating that we could model certain problem or software using graph transformations I don't know if this can be used for other things as a model and verification of certain properties. When making a model errors can be made. A way to import or export software would reduce the chance of making errors. I would also have liked to spend a bit more time on the monte carlo part. While this is a clear application of monte carlo I would have loved to look into it in a more theoretical way and check our usage against theory.\\
When looking at the course section I was very sceptical about the subject. I really enjoyed the tinkering with GROOVE. During the theoretical part, before starting to model pentago, I would have loved to have a few more exercises to flex the fingers and get to know the theory before we had to apply it in our project. As it currently stands the time allocated is very limited, being new to this subject matter one could consider it to be too limited.